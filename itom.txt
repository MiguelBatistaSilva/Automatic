from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.action_chains import ActionChains
import pandas as pd
import time

# --- INPUTS INICIAIS ---
arquivo_excel = input("Caminho do arquivo Excel: ").strip()
secretaria = input("Nome da Secretaria: ").strip()

# --- Lê o Excel ---
try:
    df = pd.read_excel(arquivo_excel)
except FileNotFoundError:
    print(f"❌ Erro: Arquivo não encontrado no caminho: {arquivo_excel}")
    exit()

# --- Configuração do Chrome ---
chrome_options = Options()
chrome_options.add_argument("--start-maximized")

# ATENÇÃO: Verifique o caminho do chromedriver
service = Service("/home/velta-int-sys/Projects/Automatic/chromedriver-linux64/chromedriver") 
driver = webdriver.Chrome(service=service, options=chrome_options)

# --- Acessa o Assyst ---
driver.get("https://cati.tjce.jus.br/assystweb/application.do")

print("⚙️ Faça login manualmente no Assyst...")

WebDriverWait(driver, 600).until(
    EC.presence_of_element_located((By.XPATH, "//span[contains(@class,'dijitTreeLabel') and text()='Requisição de Serviço']"))
)
print("✅ Login detectado!")


# ==============================================================================================
# FUNÇÃO REUTILIZÁVEL: AUTOMATIZAR BASE DE CONHECIMENTO (BK)
# Contém os Passos de Pesquisar BK até o Retorno ao Evento
# ==============================================================================================
def automatizar_bk(driver):
    """Executa a sequência completa da Base de Conhecimento."""
    
    print("\n      -> [BK] Iniciando o processo da Base de Conhecimento...")
    
    # -- PESQUISAR (Menu Conhecimento) --
    try:
        conhecimento = WebDriverWait(driver, 15).until(
            EC.element_to_be_clickable((By.ID, "knowledgeMenu")) 
        )
        conhecimento.click()
        print("      -> [BK] Clicado no botão/menu 'Conhecimento'.")
        time.sleep(3)
    except Exception as e:
        print(f"      -> [BK] ❌ Erro ao clicar no menu 'Conhecimento': {e}")
        return # Sai da função

    # -- PALAVRA-CHAVE --
    try:
        campo_bk = WebDriverWait(driver, 15).until(
            EC.presence_of_element_located((By.ID, "NONE_knowledgeProcedure_lookup_query"))
        )
        campo_bk.clear() 
        campo_bk.send_keys("itom") 
        print("      -> [BK] Campo 'Palavra-chave' preenchido.")
    except Exception as e:
        print(f"      -> [BK] ❌ Erro ao preencher 'Palavra-chave BK': {e}")

    # -- LUPA --
    try:    
        botao_pesquisar_bk = WebDriverWait(driver, 15).until(
            EC.element_to_be_clickable((By.ID, "btSearch")) 
        )
        botao_pesquisar_bk.click()
        print("      -> [BK] Clicado no botão 'Pesquisar'.")
        time.sleep(4)
    except Exception as e:
        print(f"      -> [BK] ❌ Erro ao clicar no botão 'Pesquisar': {e}")

    # -- REORDENAÇÃO (Double Click) --
    try:
        cabecalho_classificacao = WebDriverWait(driver, 15).until(
            EC.presence_of_element_located((By.ID, "knowledgeSearch_shownValues_gridHdr1"))
        )
        actions = ActionChains(driver)
        actions.double_click(cabecalho_classificacao).perform()
        print("      -> [BK] Reordenação da tabela concluída.")
        time.sleep(1)
    except Exception as e:
        print(f"      -> [BK] ❌ Erro ao reordenar a tabela: {e}")

    # -- BOTÃO DIREITO (Selecionar Artigo) -- 
    try:
        linha_artigo = WebDriverWait(driver, 15).until(
            EC.element_to_be_clickable((By.XPATH, "//div[contains(@class, 'dojoxGridRow') and contains(@class, 'rowId1')]")) 
        )
        actions = ActionChains(driver)
        actions.context_click(linha_artigo).perform()
        print("      -> [BK] Artigo da Base de Conhecimento selecionado.")
        time.sleep(1)
    except Exception as e:
        print(f"      -> [BK] ❌ Erro ao selecionar o artigo da Base de Conhecimento: {e}")

    # -- AÇÃO DE SOLUÇÃO (Clique XPath do Pai) --
    try:
        xpath_menu_item = "//td[contains(text(), 'Ação de Solução de Conhecimento')]/ancestor::tr[1]"
        acao_solucao_pai = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, xpath_menu_item)) 
        )
        acao_solucao_pai.click()
        print("      -> [BK] Clicado em 'Ação de Solução de Conhecimento'.")
        time.sleep(2) 
    except Exception as e:
        print(f"      -> [BK] ❌ Erro ao clicar na 'Ação de Solução de Conhecimento': {e}")

    # -- SALVAR AÇÃO -- 
    try:    
        botao_salvar_acao = WebDriverWait(driver, 15).until(
            EC.element_to_be_clickable((By.ID, "ManageActionForm.btSave")) 
        )
        botao_salvar_acao.click()
        print("      -> [BK] Ação de Solução de Conhecimento salva e confirmada.")
        time.sleep(2) 
    except Exception as e:
        print(f"      -> [BK] ❌ Erro ao clicar no botão 'Salvar ação': {e}")

    # -- SAIR (Voltar ao Evento) --
    try:    
        botao_voltar = WebDriverWait(driver, 15).until(
            EC.element_to_be_clickable((By.ID, "dijit_form_Button_5")) 
        )
        botao_voltar.click()
        print("      -> [BK] Retorno à tela do Chamado concluído.")
        time.sleep(3)
    except Exception as e:
        print(f"      -> [BK] ❌ Erro ao clicar no botão 'Voltar ao evento': {e}")


# ==============================================================================================
# FLUXO PRINCIPAL - CRIAÇÃO DO CHAMADO PAI
# ==============================================================================================

# 3. Expande possíveis menus pais antes do clique
# ... (O código de clique em 'Requisição de Serviço' continua aqui)

try:
    menu_element = driver.find_element(By.XPATH, "//span[contains(@class,'dijitTreeLabel') and text()='Requisição de Serviço']")
    driver.execute_script("arguments[0].scrollIntoView(true);", menu_element)
    driver.execute_script("arguments[0].click();", menu_element)
    print("✅ Clicou em 'Requisição de Serviço'")
except Exception as e:
    print("❌ Erro ao clicar:", e)

# === PREENCHIMENTO DOS CAMPOS (Usuário, Resumo, Descrição, Produtos, Categoria) ===
# ... (Todo o seu código de preenchimento continua aqui, sem alterações, até o SALVAR do Chamado Pai)
# ...

# --- USUÁRIO ATRIBUÍDO ---
# ... (Seu bloco de Usuário Atribuído)
# ...

# -- SALVAR CHAMADO PAI --
try:
    # ⚠️ REVISÃO DO ID: btlogEvent
    botao_salvar = WebDriverWait(driver, 20).until(
        EC.element_to_be_clickable((By.ID, "btlogEvent"))  
    )
    botao_salvar.click()
    print("✅ Chamado PAI salvo com sucesso.")
    time.sleep(4) 
except Exception as e:
    print(f"❌ Erro ao clicar no botão Salvar do Chamado PAI: {e}")

# ==============================================================================================
# BASE DE CONHECIMENTO - CHAMADO PAI (Reutilizando a função)
# ==============================================================================================
automatizar_bk(driver)

# ==============================================================================================
# SUPER-LOOP: CHAMADOS FILHOS
# ==============================================================================================

print("\n\n##################################")
print("# INICIANDO CRIAÇÃO DE CHAMADOS FILHOS #")
print("##################################")

for index, row in df.iterrows():
    nome_maquina = row['NOME']
    print(f"\n⚙️ Processando máquina {index + 1}/{len(df)}: {nome_maquina}")

    # 1. CONSTRUÇÃO DA DESCRIÇÃO DO CHAMADO FILHO
    description_son = (f"Solicito instalação do Itom no micro da {secretaria}:\n\n"
                      f"{row['MARCA/MODELO']} | Tombo: {row['TOMBO ANTIGO']}/{row['TOMBO NOVO']} | Nome: {row['NOME']}")
    
    # -- DUPLICAR --
    try:
        botao_duplicar = WebDriverWait(driver, 15).until(
            EC.element_to_be_clickable((By.ID, "btlogAsNewEvent")) 
        )
        botao_duplicar.click()
        print("  -> Clicado em 'Salvar como novo'.") 
    except Exception as e:
        print(f"❌ Erro ao clicar no botão 'Salvar como novo': {e}")
        continue # Pula esta máquina se falhar na duplicação

    time.sleep(0.8)

    # -- CONTINUAR (XPath Global Flexível com JS) --
    try:
        xpath_continuar_flexivel = "//span[text()='Continuar']/ancestor::span[contains(@role, 'button')]"
        time.sleep(0.5)
        
        botao_continuar = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.XPATH, xpath_continuar_flexivel)))

        driver.execute_script("arguments[0].click();", botao_continuar)

        print("  -> Clicado em 'Continuar' (XPath Global Flexível).")
        time.sleep(2)
        
    except Exception as e:
        print(f"❌ Erro TOTAL ao clicar no botão 'Continuar' para {nome_maquina}: {e}")
        print(f"⚠️ Processo interrompido para esta máquina.")
        continue # Pula a máquina se falhar na confirmação

    # -- PREENCHER DESCRIÇÃO (No Iframe) --
    try:
        iframe = WebDriverWait(driver, 20).until(
            EC.presence_of_element_located((By.XPATH, "//iframe[contains(@title, 'rtES3_formattedRemarks')]"))
        )
        driver.switch_to.frame(iframe)

        corpo_editor = WebDriverWait(driver, 20).until(
            EC.presence_of_element_located((By.CSS_SELECTOR, "body.cke_editable"))
        )
        corpo_editor.clear()
        corpo_editor.send_keys(description_son)
        driver.switch_to.default_content()
        print("  -> Descrição do chamado filho preenchida.")

    except Exception as e:
        print(f"❌ Erro ao preencher a descrição do chamado filho: {e}")
        # Continua mesmo com erro na descrição para tentar salvar/BK

    # -- SALVAR CHAMADO FILHO --
    try:
        # ⚠️ REVISÃO DO ID: btlogEvent (Disquete)
        botao_salvar = WebDriverWait(driver, 20).until(
            EC.element_to_be_clickable((By.ID, "btlogEvent")))
        
        botao_salvar.click()
        
        print("  -> Chamado filho salvo com sucesso.")
        time.sleep(2) 
        
    except Exception as e:
        print(f"❌ Erro ao clicar no botão Salvar do Chamado Filho: {e}")
        continue # Pula a máquina se falhar ao salvar

    # -- BASE DE CONHECIMENTO (Reutilizando a função) --
    automatizar_bk(driver)

    print(f"✔️ Concluído o ciclo para a máquina: {nome_maquina}.")


print("\n🎉 Automação de criação de chamados filhos concluída.")
# Opcional: driver.quit() para fechar o navegador no final
